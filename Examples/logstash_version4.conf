# =============================================================================
# VERSION 4: Intelligence & Error Handling 
# =============================================================================
# File: logstash_version4.conf
# Purpose: Add business logic, threat intelligence, and error handling

input {
  syslog {
    port => 5514
    type => "syslog"
  }
}

filter {
  # Preserve raw message for debugging
  mutate { add_field => { "raw_message_backup" => "%{message}" } }
  
  # Basic syslog parsing
  grok {
    match => {
      "message" => "<%{POSINT:priority}>%{INT:version} %{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:host} %{WORD:application} %{DATA:proc_id} %{DATA:msg_id} %{GREEDYDATA:raw_message}"
    }
    add_tag => ["parsed_syslog"]
    tag_on_failure => ["syslog_parse_failure"]
  }
  
  # Priority parsing
  if [priority] {
    ruby {
      code => "
        priority = event.get('priority').to_i
        facility = priority >> 3
        severity = priority & 7
        event.set('facility', facility)
        event.set('severity_level', severity)
        severity_labels = ['Emergency', 'Alert', 'Critical', 'Error', 'Warning', 'Notice', 'Info', 'Debug']
        event.set('severity', severity_labels[severity] || 'Unknown')
      "
    }
  }
  
  # Application-specific processing
  if [application] =~ /(?i)veeam/ {
    mutate { add_field => { "app_type" => "veeam" } }
    
    # Parse all Veeam fields
    grok { match => { "raw_message" => "enterpriseId=\"%{DATA:enterprise_id}\"" } }
    grok { match => { "raw_message" => "categoryId=%{INT:category_id}" } }
    grok { match => { "raw_message" => "instanceId=%{INT:instance_id}" } }
    grok { match => { "raw_message" => "DetectionTimeUTC=\"%{DATA:detection_time_utc}\"" } }
    grok { match => { "raw_message" => "OibID=\"%{DATA:oib_id}\"" } }
    grok { match => { "raw_message" => "ActivityType=\"%{DATA:activity_type}\"" } }
    grok { match => { "raw_message" => "UserName=\"%{DATA:username}\"" } }
    grok { match => { "raw_message" => "ObjectName=\"%{DATA:object_name}\"" } }
    grok { match => { "raw_message" => "VbrHostName=\"%{DATA:vbr_hostname}\"" } }
    grok { match => { "raw_message" => "Description=\"%{DATA:description}\"" } }
    
    # Username parsing
    if [username] {
      grok { match => { "username" => "(?<user_domain>[^\\\\]+)\\\\(?<clean_username>.+)" } }
    }
    
    # Type conversion
    mutate {
      convert => { 
        "category_id" => "integer"
        "instance_id" => "integer" 
      }
    }
    
    # ========================================================================
    # INTELLIGENCE LAYER 
    # ========================================================================
    
    # Threat categorization based on activity type
    if [activity_type] == "EncryptedData" {
      mutate {
        add_field => { 
          "threat_type" => "potential_ransomware"
          "event_category" => "malware"
          "business_impact" => "high"
          "alert_priority" => "critical"
          "recommendation" => "Immediate investigation required - potential ransomware activity"
        }
      }
    }
    else if [activity_type] == "SuspiciousActivity" {
      mutate {
        add_field => { 
          "threat_type" => "anomalous_behavior"
          "event_category" => "suspicious"
          "business_impact" => "medium"
          "alert_priority" => "high"
          "recommendation" => "Review user activity and system access"
        }
      }
    }
    else if [activity_type] =~ /(?i)delete|remove/ {
      mutate {
        add_field => { 
          "threat_type" => "data_destruction"
          "event_category" => "data_loss"
          "business_impact" => "high"
          "alert_priority" => "high"
          "recommendation" => "Verify deletion was authorized and check backup integrity"
        }
      }
    }
    else {
      mutate {
        add_field => { 
          "threat_type" => "unknown"
          "event_category" => "informational"
          "business_impact" => "low"
          "alert_priority" => "medium"
          "recommendation" => "Monitor for patterns"
        }
      }
    }
    
    # Enhanced user context
    if [clean_username] {
      # Flag service accounts vs human users
      if [clean_username] =~ /(?i)svc|service|system|backup/ {
        mutate { add_field => { "user_type" => "service_account" } }
      } else {
        mutate { add_field => { "user_type" => "human_user" } }
      }
    }
    
    # Time-based analysis
    ruby {
      code => "
        require 'time'
        now = Time.now
        hour = now.hour
        
        if hour >= 22 || hour <= 6
          event.set('time_context', 'after_hours')
          event.set('suspicious_timing', true)
        elsif hour >= 9 && hour <= 17
          event.set('time_context', 'business_hours')
          event.set('suspicious_timing', false)
        else
          event.set('time_context', 'extended_hours')
          event.set('suspicious_timing', false)
        end
      "
    }
  }
  else {
    mutate { add_field => { "app_type" => "unknown" } }
  }
  
  # ========================================================================
  # ERROR HANDLING & DEBUGGING
  # ========================================================================
  
  # Track parsing success/failure
  if "_grokparsefailure" in [tags] {
    mutate {
      add_field => { 
        "parsing_status" => "failed"
        "parsing_error" => "grok_pattern_mismatch"
      }
      add_tag => ["parsing_failure"]
    }
  } else {
    mutate { add_field => { "parsing_status" => "success" } }
  }
  
  # Set final event type
  if [app_type] == "veeam" and [threat_type] {
    mutate { add_field => { "event_type" => "security_event" } }
  } else {
    mutate { add_field => { "event_type" => "system_log" } }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "syslog-%{+YYYY.MM.dd}"
  }
  
  # Debug output - remove in production
  stdout { codec => rubydebug }
  
  # Optional: Separate high-priority alerts to different index
  if [alert_priority] == "critical" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "security-alerts-%{+YYYY.MM.dd}"
    }
  }
}
