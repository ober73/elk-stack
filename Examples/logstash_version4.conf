input {
  syslog {
    port => 5514
    type => "syslog"
  }
}
filter {
  # Parse the basic syslog format first
  grok {
    match => {
      "message" => "<%{POSINT:priority}>%{INT:version} %{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:host} %{WORD:application} %{GREEDYDATA:raw_message}"
    }
    add_tag => ["parsed_syslog"]
  }
  
  # Smart application detection
  if [application] == "OOTBI" {
    mutate { add_field => { "app_type" => "ootbi" } }
  }
  else if [application] =~ /(?i)veeam/ {
    mutate { add_field => { "app_type" => "veeam" } }
    
    # Step 4: Simpler approach - Parse key fields step by step
    
    # First, extract just the enterprise ID
    grok {
      match => {
        "raw_message" => "enterpriseId=\"%{DATA:enterprise_id}\""
      }
      add_tag => ["veeam_enterprise_parsed"]
    }
    
    # Then extract the main structured data
    grok {
      match => {
        "raw_message" => "categoryId=%{INT:category_id}"
      }
      add_tag => ["veeam_category_parsed"]
    }
    
    grok {
      match => {
        "raw_message" => "ActivityType=\"%{DATA:activity_type}\""
      }
      add_tag => ["veeam_activity_parsed"]
    }
    
    grok {
      match => {
        "raw_message" => "UserName=\"%{DATA:username}\""
      }
      add_tag => ["veeam_user_parsed"]
    }
    
    grok {
      match => {
        "raw_message" => "ObjectName=\"%{DATA:object_name}\""
      }
      add_tag => ["veeam_object_parsed"]
    }
   
    # Extract domain and username (because DOMAIN\user is common)
    if [username] {
      grok {
        match => {
          "username" => "(?<user_domain>[^\\\\]+)\\\\(?<clean_username>.+)"
        }
      }
    }
   
    # Convert numeric fields to proper types
    if [category_id] {
      mutate { convert => { "category_id" => "integer" } }
    }
    if [instance_id] {
      mutate { convert => { "instance_id" => "integer" } }
    }
    
    # Parse the detection timestamp for better date handling
    if [detection_time] {
      date {
        match => [ "detection_time", "MM/dd/yyyy HH:mm:ss" ]
        target => "detection_timestamp"
      }
    }
  }
  else {
    mutate { add_field => { "app_type" => "unknown" } }
  }

  # Ruby filter for additional processing
  ruby {
    code => "
      # Add your Ruby code here
      # Example: event.set('processed_timestamp', Time.now.to_i)
    "
  }
}
output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "raw-logs-%{+YYYY.MM.dd}"
  }
  # Useful for debugging
  stdout { codec => rubydebug }
}
